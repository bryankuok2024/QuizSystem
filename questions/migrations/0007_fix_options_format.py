# Generated by Django 5.2.1 on 2025-06-10 10:00

from django.db import migrations
import json

def fix_options_format_robust(apps, schema_editor):
    """
    Corrects the JSON structure in the options field for a specific range of questions.
    This version is more robust and handles cases where the field might be a string
    or a list. It transforms options from '["{\\"A\\": ...}"]' or ['{"A": ..."}'] 
    to {"A": "..."}.
    """
    Question = apps.get_model('questions', 'Question')
    questions_to_fix = Question.objects.filter(id__range=(149, 168))
    
    updated_count = 0
    skipped_count = 0
    
    print(f"\\nProcessing {questions_to_fix.count()} questions (IDs 149-168)...")
    
    for question in questions_to_fix:
        options_data = question.options
        data_to_parse = None

        # Case 1: The data is a string that looks like a list, e.g., '["..."]'
        if isinstance(options_data, str):
            try:
                # First, parse the outer string into a list
                parsed_list = json.loads(options_data)
                if isinstance(parsed_list, list) and len(parsed_list) == 1 and isinstance(parsed_list[0], str):
                    data_to_parse = parsed_list[0]
            except json.JSONDecodeError:
                print(f"  - SKIPPING Question ID: {question.id}. Data is a string, but not a valid JSON list.")
                skipped_count += 1
                continue
        
        # Case 2: The data is already a list, e.g., ['...']
        elif isinstance(options_data, list):
            if len(options_data) == 1 and isinstance(options_data[0], str):
                data_to_parse = options_data[0]
            else:
                # This handles cases where the list is empty or has a different structure
                pass # Already correct or a different issue, so we skip.
        
        # If we have something to parse, let's do it
        if data_to_parse:
            try:
                correct_options_dict = json.loads(data_to_parse)
                if isinstance(correct_options_dict, dict):
                    question.options = correct_options_dict
                    question.save(update_fields=['options'])
                    updated_count += 1
                    print(f"  - FIXED Question ID: {question.id}.")
                else:
                    print(f"  - SKIPPING Question ID: {question.id}. Inner content is not a dictionary.")
                    skipped_count += 1
            except json.JSONDecodeError:
                print(f"  - SKIPPING Question ID: {question.id}. Inner string is not valid JSON.")
                skipped_count += 1
        else:
            # This will catch cases that didn't fit Case 1 or 2, like already correct dicts
            skipped_count += 1

    print(f"\\nMigration finished. Successfully updated {updated_count} questions. Skipped {skipped_count} questions.")


class Migration(migrations.Migration):

    dependencies = [
        ('questions', '0006_alter_subject_options_alter_subject_major_subject'),
    ]

    operations = [
        migrations.RunPython(fix_options_format_robust, migrations.RunPython.noop),
    ] 